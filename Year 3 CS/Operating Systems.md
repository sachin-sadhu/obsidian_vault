# Intro
Operating system is software that manages physical hardware, on behalf of other programs. Needs to be **convenient**, **efficient** and **flexible**. Users use system and application level programs.
## Roles of OS
* Resource allocation of CPU, memory storage and network
* Concerned with fairness and efficiency. 
* Manages life cycle of machine/applications.
* Prevents users/programs accessing data/hardware they shouldn't.
* Provides consistent API for file system, sockets, graphics etc.
# Kernel
Core of the OS. Interfaces with and abstracts over hardware. Unit of work is called 'job'/'task'. Typical cycle is fetch -> decode -> execute. Interrupts are always handled by kernel.
### Device Trees
Config file that tells the OS where to find devices in the system. "Static" discovery as the location and config of devices are known in advance.

## Direct Memory Access (DMA)
Technique for allowing some systems to access main memory without the need for the CPU. For example, if I/O want to write to a memory location, CPU must copy data from I/O to a register, and then copy that data to a location in memory. Requires 2 memory cycles.  

DMA is a processor that helps reduce need for CPU. In order to do this it must know: 
* Read/write operation
* Address of the I/O
* Address of memory
* Size of transfer block

Actual transfer of data involves following steps:
* DMA requests bus to start transfer
* CPU grants bus to DMA controller
* DMA transfers words until the transfer is complete or CPU requests bus
* When block transfer is finished, DMA can notify the CPU via an interrupt.


## Interrupts
Interrupts cause the CPU to pause current execution and transfer control to an **Interrupt Service Routine (ISR)**. Hardware/software can both send interrupts to the CPU. Hardware sending interrupts is an asynchronous event. Software sending interrupts is a synchronous event.

An interrupt is a signal from a device that an event has occured. When an interrupt occurs, the CPU first pushes all the register values of the interrupted process to the stack, handles the interrupt, and then pops the values back off the stack. This allows the processor to resume execution of the interrupted process. $iretq$ is the instruction that causes the processor to return to interrupted process.

### Interrupt controllers
Device responsible for reporting an interrupt to the CPU. CPU might have to figure out exactly which device caused the interrupt, this is usually done by asking all the devices that could have produced the interrupt if that actually produced it.
![[Screenshot 2024-10-14 at 1.53.16 PM.png]]

### Interrupt Descriptor Table (IDT)
Configures the behaviour of the processor when an interrupt occurs. Contains 256 entries, means up to 256 interrupts can be handled. Each entry corresponds to an IRQ (Interrupt Request) number. Basically an entry contains a **memory address** to jump to when the interrupt occurs. Job of the ISR to save current state of processor when the interrupt occurs. 

### Sources of Interrupts
#### Hardware
* I/O operation complete
* Timer expired
* Hardware failure
#### Software
* Request for system call
* Divide by zero
* Illegal instruction
* Illegal memory access
* Known exceptions

### Message-Signalled Interrupts (MSI)
Interrupts generated by PCIe devices will trigger a memory write, instead of activating a physical interrupt line. Memory write will then get handled by CPU chip's interrupt logic.
# Booting
### Power On
System is in a unknown state. Only known details are the mode of the CPU, and the value of the program counter (PC).

Difference modes are:
* Real mode (startup mode) 
* Protected mode
* Long mode
### BIOS/UEFI
Stands for Basic Input/Output System. Firmware that prepares system to load an OS. UEFI is the new BIOS.

### POST
Stands for Power On Self Test. Tests include CPU checks, memory checks, device & BIOS checks.

### ACPI
Stands for Advanced Configuration and Power Interface. One of first jobs of OS is to locate the ACPI tables. Once the tables are parsed, the OS can start initialising devices. OS finds the ACPI table by scanning through lower memory.

### Bootloader
Program that actually loads the operating system and transfers control to it. 

unified l1 cache, cache that does not split data and instructions
diff parts of physical address space do diff things

os must make sure it does not allocate pages to where it currently is

# Memory 
Main memory is used to store data and programs for immediate use. An **address space** defines a range of discrete addresses that can be accessed.

## Physical Memory
Actual real memory that stores data. Physical address space contains addresses that correspond to **physical memory**, but also to things such as BIOS ROM etc. Physical address space on x86 systems comprises of 52-bit addresses. This means there are up to $2^{52}$ addresses available. Each address is generally 1 byte. 
### Paging
The smallest unit of management is called a **page**, typical size of a page is 4 KiB (4096 bytes). Pages are a fixed size, contiguous in the address space and aligned to multiples of their size.

## Buddy System
Technique of allocating memory blocks to different processes. Basic idea is to maintain lists of free power of two sized blocks. The exponent of the power is the block's order. i.e order 0 will contain blocks of $2^0$  = 1 page. order 2 will contain blocks of $2^2$ = 4 page.

### Allocation
We then insert all blocks into list of highest order. When a request for a block comes in, we check the list of that order to see if there are any free blocks. If there are we allocate that block, if not we go to the next highest order and split the block in half and allocate it.
### Free
When we free a block of memory we insert that block into the list of order. If the block's buddy is also present in that order, we combine the 2 and move it upwards to a higher order. The buddy of a block is calculated by **starting_number XOR order**.

## Page Tables
Technique for converting logical addresses into physical addresses. Idea is to store a table containing entries that store physical address.

For a given 10 bit logical address, use first 3 bits to store index into page table, and remaining 7 bits to store offset into that given page. In this scenario, the page table could store 8 different entries and each page would be 128 bytes. 

Having an array that stores these address mappings would be super memory intensive, and also most of virtual address space is not in use as it is so big. Solution is to use multi level page tables.

### Multi-Level Page Tables
Split the page table up into multiple levels. i.e for a 2 level page table, the first page table's entry would point to the next page table. The deeper page table would then point to the actual location of physical memory. 

For a given 10 bit logical address, use first 2 bits to store index of first page table, next 2 bits to store index of second page table, and last 6 bits to store offset into the page. 

Much more efficient as in practice, only the first page table must exist, if there are no mappings in the second level page table, it does not need to be created until it is needed.

### Translation Lookaside Buffer (TLB) 

This added level of indirection means there are additional steps to obtaining a physical memory address. TLB is a cache of high speed associative registers. Keys are virtual page numbers and values are physical page numbers. When we need to find the cooresponding physica page number for a virtual page number, we first check the TLB. If we get a hit, great, otherwise we do the page walk and create a new entry in the TLB. 

## Operating System Design
OS function are partitioned into different layers. Lowest (Layer 0) is the actual hardware, while the highest is the actual user interface. A layer is an implementation of an abstract object, this means it encapsulates its data and operations. Layers only use the functions of the next lowest layer. Adding more layers of abstraction introduces more inefficiency.

### Monolithic Kernels
eg. : Linux, kernel code is huge and in one block. File system, Inter process communication (IPC), scheduler, devices and virtual memory all contained in kernel code.

### Microkernels
Removes non-essential functionality from the kernel. Results in smaller, simpler kernel.
* Contains only lowest level functions such as scheduler, VM, IPC.
* Use message passing to call services, instead of system calls. 

Pros : Easier to extend or modify OS service. Increased reliability. Simplifies porting.
Cons : More performance overheads due to communication between services. More expensive than simple system call.

### Modular Kernels
Uses an OOP approach. Dynamically loads in additional functionality via modules which the kernel can load in. Similar to microkernel in that most functionality is outside the core kernel, but can still run in kernel mode. Results in no overhead message passing.

## Devices

A device is a piece of **hardware** that performs a particular function in a computer, can be external/internal.
* Keyboard
* Mouse
* Timer
* Interrupt controller
* RAM

A **device driver** is a piece of software that can speak the language of the device, known how to program/operate/read from it etc. Usually implements some API for the rest of the OS to use. Allows communication between  device and OS.  
![[Pasted image 20241012230632.png]]
Devices are usually connected to upstream controllers, which are also devices. 
![[Pasted image 20241012230821.png]]

### Device Controllers
Intermediate electronic device that is able to communicate between the OS and the actual hardware device. Controller communicates between device and OS using system bus. Some IO devices will have DMA via their controllers.

Controllers can usually control more than 1 IO device but common to only control 1. Some devices have controllers embedded inside them while some are on motherboard.

### Bus
Method of communication that allows multiple components to speak to each other. 
Some features of different buses are :
* Discover - Seeing connected devices
* DMA
* Packet/stream based I/O

## Peripheral Component Interface (PCI)
PCI is the main hardware bus / way different devices are connected. Allows data transfer between peripheral devices and motherboard.
![[Pasted image 20241012233304.png]]
Every device will have a configuration space that contains hardware IDs and resource requirements. Firmware then allocates memory address ranges to each device. The device will respond to any memory request by CPU to an address in those ranges. 

PCI devices can also send interrupts.
* Legacy Interrupts : physical pins that go high to signal an interrupt
* Message signalled interrupts : Writes to a particular location in memory to signal an interrupt

## Universal Serial Bus (USB)
Industry standard protocol for connecting peripheral devices to computer. Supports hot plugging and automatic device discovery. Unlike PCI, no raw memory access, no direct interrupts. Transfers are packet/stream based. Devices expose endpoints which packets are addressed to. Basically no memory address to write to that will speak to the USB

Hot swapping basically means you can plug out and device and plug in a new one without shutting down host system.

Old devices had to be manually confiugured, configuration is done automatically with USB

## PCIe Vs USB
PCIe is generally used to connect internal high speed componenents such as GPU, SSD etc. USB is mainly used to connect external peripherals such as keyboard, monitor etc. Designed for hot swapping.

PCIe uses internal slots located on the motherboard, USB uses external ports on motherboard/front of computer to easily connect/disconnect devices.  PCIe has lower latency than USB

## Physical Interfaces

Ways of enabling transfer of data to/from storage devices. Need to be high-speed, low latency links to cope with high transfer speeds of modern storage.
### Integrated Drive Electronics (IDE)
IDE interface is a **parallel bus-style** interface, for internal connection of storage devices. IDE refers to the fact that the drive controller exists on the actual drive itself.

### Industry Standard Architecture (ISA) bus
Original internal bus of PC architecture. 16 bit parallel bus, predecessor of PCI bus.

### NVME
Logical standard for high-performance storage devices such as SSDs. Devices are connected directly to PCIe bus. 

## Logical Data Storage

Data accesses are often abstracted to logical blocks. Logical blocks are sector sizes of underlying storage devices.
### Reliability/Redundancy
Reliability refers to even if some disc is corrupted we can still access it. Usually done through redundancy. i.e If we have a logical disk, we can store the data on 2 seperate physical disks. That way, even if 1 physical disk is corrupted, we can still access the data from the other disk done through redundancy, i.e. i.e if If we have 2 physical a logical disk, we can store the 2data on s2 seperate physical disks . That way, even if 1 physical disk is corrupted, we can still access the data from the other disk. 
![[Pasted image 20241028214331.png]]
### Performance

We can also take advantage of **parrellism** here, we can read different blocks from different disks at the same time.

We can also increase logical disk by combining multiple physical disks.
![[Pasted image 20241028214539.png]]

Striping is the idea of splitting up data between different disks, to take advantage of both paralleism and increasing storage. i.e store even blocks on physical disk 1, odd blocks on physical disk 2.
## Questions

* How do peripherals that connect via bluetooth differ?

## C++ Tips

__attribute(packed)__ forces compiler to not align fields in structs and therefore use the minimum amount of bytes.




