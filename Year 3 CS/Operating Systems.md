# Intro
Operating system is software that manages physical hardware, on behalf of other programs. Needs to be **convenient**, **efficient** and **flexible**. Users use system and application level programs.
## Roles of OS
* Resource allocation of CPU, memory storage and network
* Concerned with fairness and efficiency. 
* Manages life cycle of machine/applications.
* Prevents users/programs accessing data/hardware they shouldn't.
* Provides consistent API for file system, sockets, graphics etc.
# Kernel
Core of the OS. Interfaces with and abstracts over hardware. Unit of work is called 'job'/'task'. Typical cycle is fetch -> decode -> execute. Interrupts are always handled by kernel.
### Device Trees
Config file that tells the OS where to find devices in the system. "Static" discovery as the location and config of devices are known in advance.

## Direct Memory Access (DMA)
Technique for allowing some systems to access main memory without the need for the CPU. For example, if I/O want to write to a memory location, CPU must copy data from I/O to a register, and then copy that data to a location in memory. Requires 2 memory cycles.  

DMA is a processor that helps reduce need for CPU. In order to do this it must know: 
* Read/write operation
* Address of the I/O
* Address of memory
* Size of transfer block

Actual transfer of data involves following steps:
* DMA requests bus to start transfer
* CPU grants bus to DMA controller
* DMA transfers words until the transfer is complete or CPU requests bus
* When block transfer is finished, DMA can notify the CPU via an interrupt.

DMA controller is piece of specialised hardware. CPU configures controller with source and destination addresses for data transfer. Controller then takes charge of transferring the data, transferring data between I/O device and memory directly. Controller will then send an interrupt to CPU letting it know transfer has completed. 


## Interrupts
Interrupts cause the CPU to pause current execution and transfer control to an **Interrupt Service Routine (ISR)**. Hardware/software can both send interrupts to the CPU. Hardware sending interrupts is an asynchronous event. Software sending interrupts is a synchronous event.

An interrupt is a signal from a device that an event has occured. When an interrupt occurs, the CPU first pushes all the register values of the interrupted process to the stack, handles the interrupt, and then pops the values back off the stack. This allows the processor to resume execution of the interrupted process. $iretq$ is the instruction that causes the processor to return to interrupted process.

### Interrupt controllers
Device responsible for reporting an interrupt to the CPU. CPU might have to figure out exactly which device caused the interrupt, this is usually done by asking all the devices that could have produced the interrupt if that actually produced it.
![[Screenshot 2024-10-14 at 1.53.16 PM.png]]

### Interrupt Descriptor Table (IDT)
Configures the behaviour of the processor when an interrupt occurs. Contains 256 entries, means up to 256 interrupts can be handled. Each entry corresponds to an IRQ (Interrupt Request) number. Basically an entry contains a **memory address** to jump to when the interrupt occurs. Job of the ISR to save current state of processor when the interrupt occurs. 

### Sources of Interrupts
#### Hardware
* I/O operation complete
* Timer expired
* Hardware failure
#### Software
* Request for system call
* Divide by zero
* Illegal instruction
* Illegal memory access
* Known exceptions

### Message-Signalled Interrupts (MSI)
Interrupts generated by PCIe devices will trigger a memory write, instead of activating a physical interrupt line. Memory write will then get handled by CPU chip's interrupt logic.

### Maskable/Unmaskable Interrupts

Maskable interrupts are interrupts that the CPU can temporarily ignore such as keyboard/mouse input. Might choose to ignore these interrupts when executing a critical task.

Unmaskable interrupts are interrupts that the CPU must handle immediately such as hardware failures, system errors.

# Booting
### Power On
System is in a unknown state. Only known details are the mode of the CPU, and the value of the program counter (PC).

Difference modes are:
* Real mode (startup mode) 
* Protected mode
* Long mode
### BIOS/UEFI
Stands for Basic Input/Output System. Firmware that prepares system to load an OS. UEFI is the new BIOS. Will also initialise and creates the ACPI table. RSDP is then placed in a well-defined memory location.

### POST
Stands for Power On Self Test. Tests include CPU checks, memory checks, device & BIOS checks.
### Bootloader
Upon completing POST, firmware will invoke the boot loader which is the program that actually loads the operating system and transfers control to it. Boot loader is in charge of locating the OS kernel on the boot device, loads it into main memory and starts its execution.

unified l1 cache, cache that does not split data and instructions
diff parts of physical address space do diff things

os must make sure it does not allocate pages to where it currently is

### ACPI
Stands for Advanced Configuration and Power Interface. One of first jobs of OS is to locate the ACPI tables. Once the tables are parsed, the OS can start initialising devices. OS finds the ACPI table by scanning through lower memory and attempting to find the RSDP.

Facilitates control of hardware such as power management, thermal control. OS locates the ACPI table using Root System Description Pointer (RSDP).

### Init Process

First process created by the OS that runs in user-space. Ancestor of all processes.

### OS Initilisation

Locate ACPI tables, set up page tables, initialise memory allocator, prepare interrupts, schedulers, mount storage, run user-space.

# Memory 
Main memory is used to store data and programs for immediate use. An **address space** defines a range of discrete addresses that can be accessed.

## Physical Memory
Actual real memory that stores data. Physical address space contains addresses that correspond to **physical memory**, but also to things such as BIOS ROM etc. Physical address space on x86 systems comprises of 52-bit addresses. This means there are up to $2^{52}$ addresses available. Each address is generally 1 byte. 

External Fragmentation is when chunks of memory across the address space are allocated, leaving multiple 'holes'. This results in not being able to allocate contingouous chunks of memory even though there might be enough. 

Internal Fragmentation is when you allocate too much memory to a given process, and not all of it is used up.

### Segmentation
Method of converting logical addresses to physical addreses. Segment table stores logical segments to physical memory addresses. Each entry also stores max offset, to ensure processes don't try to access memory in another segment. $$Physical Address=BaseAddress+Offset$$
Accesing address $0x0020$ in segment 3, the system will look up base address for segment 3 in segment table, and add offset $0x0020$ to the base address.
### Paging
The smallest unit of management is called a **page**, typical size of a page is 4 KiB (4096 bytes). Pages are a fixed size, contiguous in the address space and aligned to multiples of their size.

## Buddy System
Technique of allocating memory blocks to different processes. Basic idea is to maintain lists of free power of two sized blocks. The exponent of the power is the block's order. i.e order 0 will contain blocks of $2^0$  = 1 page. order 2 will contain blocks of $2^2$ = 4 page.

### Allocation
We then insert all blocks into list of highest order. When a request for a block comes in, we check the list of that order to see if there are any free blocks. If there are we allocate that block, if not we go to the next highest order and split the block in half and allocate it.
### Free
When we free a block of memory we insert that block into the list of order. If the block's buddy is also present in that order, we combine the 2 and move it upwards to a higher order. The buddy of a block is calculated by **starting_number XOR order**.

## Page Tables
Technique for converting logical addresses into physical addresses. Idea is to store a table containing entries that store physical address.

For a given 10 bit logical address, use first 3 bits to store index into page table, and remaining 7 bits to store offset into that given page. In this scenario, the page table could store 8 different entries and each page would be 128 bytes. 

Having an array that stores these address mappings would be super memory intensive, and also most of virtual address space is not in use as it is so big. Solution is to use multi level page tables.

Page tables also contain protection flags which dictate what operations can be performed on a certain page. eg. read/write only, kernel/user mode. 

### Multi-Level Page Tables
Split the page table up into multiple levels. i.e for a 2 level page table, the first page table's entry would point to the next page table. The deeper page table would then point to the actual location of physical memory. 

For a given 10 bit logical address, use first 2 bits to store index of first page table, next 2 bits to store index of second page table, and last 6 bits to store offset into the page. 

Much more efficient as in practice, only the first page table must exist, if there are no mappings in the second level page table, it does not need to be created until it is needed.

### Translation Lookaside Buffer (TLB) 

This added level of indirection means there are additional steps to obtaining a physical memory address. TLB is a cache of high speed associative registers. Keys are virtual page numbers and values are physical page numbers. When we need to find the cooresponding physica page number for a virtual page number, we first check the TLB. If we get a hit, great, otherwise we do the page walk and create a new entry in the TLB. 

OS must make sure to flush the TLB if changes are made to pages in the TLB.

### Demand Paging

Instead of loading in pages for an entire process into memory at the start, only load in pages when they are required. Page tables will store 'valid/invalid' bit. If entry is set to valid, means page is currently loaded in memory, if invalid, means page is not currently mapped to a physical page. 

### Copy on write
If many processes share the same data, we can create pages that they all share as long as they are only reading the pages. If a process wants to 'write' to a page, it will first make a copy of that page and then 'write' to the copied page. 

## Operating System Design
OS function are partitioned into different layers. Lowest (Layer 0) is the actual hardware, while the highest is the actual user interface. A layer is an implementation of an abstract object, this means it encapsulates its data and operations. Layers only use the functions of the next lowest layer. Adding more layers of abstraction introduces more inefficiency.

### Monolithic Kernels
eg. : Linux, kernel code is huge and in one block. File system, Inter process communication (IPC), scheduler, devices and virtual memory all contained in kernel code.

### Microkernels
Removes non-essential functionality from the kernel. Results in smaller, simpler kernel.
* Contains only lowest level functions such as scheduler, VM, IPC.
* Use message passing to call services, instead of system calls. 

Pros : Easier to extend or modify OS service. Increased reliability. Simplifies porting.
Cons : More performance overheads due to communication between services. More expensive than simple system call.

### Modular Kernels
Uses an OOP approach. Dynamically loads in additional functionality via modules which the kernel can load in. Similar to microkernel in that most functionality is outside the core kernel, but can still run in kernel mode. Results in no overhead message passing.

## Devices

A device is a piece of **hardware** that performs a particular function in a computer, can be external/internal.
* Keyboard
* Mouse
* Timer
* Interrupt controller
* RAM

A **device driver** is a piece of software that can speak the language of the device, known how to program/operate/read from it etc. Usually implements some API for the rest of the OS to use. Allows communication between  device and OS.  
![[Pasted image 20241012230632.png]]
Devices are usually connected to upstream controllers, which are also devices. 
![[Pasted image 20241012230821.png]]

### Device Controllers
Intermediate electronic device that is able to communicate between the OS and the actual hardware device. Controller communicates between device and OS using system bus. Some IO devices will have DMA via their controllers.

Controllers can usually control more than 1 IO device but common to only control 1. Some devices have controllers embedded inside them while some are on motherboard.

Controllers contain registers for data/control signals. OS can read/write to these registers to get the controllers to perform some action. CPU uses special 'in/out' instructions to write to the registers.

#### MMIO

This allows the controller registers to be mapped into some region in memory, then CPU can read write to these registers just like any other memory adddress. 

### Bus
Method of communication that allows multiple components to speak to each other. 
Some features of different buses are :
* Discover - Seeing connected devices
* DMA
* Packet/stream based I/O

## Peripheral Component Interface (PCI)
PCI is the main hardware bus / way different devices are connected. Allows data transfer between peripheral devices and motherboard.
![[Pasted image 20241012233304.png]]
Every device will have a configuration space that contains hardware IDs and resource requirements. Firmware then allocates memory address ranges to each device. The device will respond to any memory request by CPU to an address in those ranges. 

PCI devices can also send interrupts.
* Legacy Interrupts : physical pins that go high to signal an interrupt
* Message signalled interrupts : Writes to a particular location in memory to signal an interrupt

## Universal Serial Bus (USB)
Industry standard protocol for connecting peripheral devices to computer. Supports hot plugging and automatic device discovery. Unlike PCI, no raw memory access, no direct interrupts. Transfers are packet/stream based. Devices expose endpoints which packets are addressed to. Basically no memory address to write to that will speak to the USB

Hot swapping basically means you can plug out and device and plug in a new one without shutting down host system.

Old devices had to be manually confiugured, configuration is done automatically with USB

## PCIe Vs USB
PCIe is generally used to connect internal high speed componenents such as GPU, SSD etc. USB is mainly used to connect external peripherals such as keyboard, monitor etc. Designed for hot swapping.

PCIe uses internal slots located on the motherboard, USB uses external ports on motherboard/front of computer to easily connect/disconnect devices.  PCIe has lower latency than USB

## Physical Interfaces

Ways of enabling transfer of data to/from storage devices. Need to be high-speed, low latency links to cope with high transfer speeds of modern storage.
### Integrated Drive Electronics (IDE)
IDE interface is a **parallel bus-style** interface, for internal connection of storage devices. IDE refers to the fact that the drive controller exists on the actual drive itself.

### Industry Standard Architecture (ISA) bus
Original internal bus of PC architecture. 16 bit parallel bus, predecessor of PCI bus.

### NVME
Logical standard for high-performance storage devices such as SSDs. Devices are connected directly to PCIe bus. 

## Logical Data Storage

Data accesses are often abstracted to logical blocks. Logical blocks are sector sizes of underlying storage devices.
### Reliability/Redundancy
Reliability refers to even if some disc is corrupted we can still access it. Usually done through redundancy. i.e If we have a logical disk, we can store the data on 2 seperate physical disks. That way, even if 1 physical disk is corrupted, we can still access the data from the other disk done through redundancy, i.e. i.e if If we have 2 physical a logical disk, we can store the 2data on s2 seperate physical disks . That way, even if 1 physical disk is corrupted, we can still access the data from the other disk. 
![[Pasted image 20241028214331.png]]
### Performance

We can also take advantage of **parrellism** here, we can read different blocks from different disks at the same time.

We can also increase logical disk by combining multiple physical disks.
![[Pasted image 20241028214539.png]]

Striping is the idea of splitting up data between different disks, to take advantage of both paralleism and increasing storage. i.e store even blocks on physical disk 1, odd blocks on physical disk 2.

## File Systems

Mechanism for organising and storing data and programs.
### Files
**Named** sequence of bits, bytes etc. Usually have a format, although including extension after file name is pure convention and offers no actual use. Have metadata such as unique identifer, size, protection etc. Files are collection of blocks on storage devices. File inodes usually contain pointers to these different blocks. These blocks can live on different regions in the storage device. 
### Directories
Hierarchical organisation of the file system. Contains **pointers** to files and other directories. 
![[Pasted image 20241104204608.png]]

### File Tables / File Descriptor
OS keeps track of open files in the "open file table". File descriptor is the index used to refer to the relevant entry in the file. This prevents the OS from having to search through file system to find the file every time an operation on it is requested.

Each process also has a its own open file table. This file table stores a pointer of where it currently is in the file. Every time a process opens a file, a counter in the system wide open file table is incremented. When the counter reaches 0, no processes are using that file, and hence the system open file table can evict that entry. 

### File Types
File usually contain a magic number that specifies the type of file it is, such as .pdf or .exe.

### Partitioning a Device

Refers to splitting a storage device into multiple sections that each store a logical file system .

### System Calls
System calls are a way for user programs to ask the OS to perform operations on it's behalf that can normally only be executed by kernel code.

## Threads
Basic unit of CPU utilisation. Each thread has its own set of registers, PC, stack. Shares with other threads in the same process the code/data section.

Benefits of threads are as follows : 
* Responsiveness
* Resource sharing
* Less overhead when context switching compared to process

#### Kernel/User Threads
These are threads created and managed by the OS. User threads are threads created in user-space. The underlying OS has no idea about them. 

### Monitor 

Provide the user with an Abstract Data Type (ADT) to interact with the shared critical section. This ADT should have functions for interacting with the variables in a thread-safe manner by using techniques such as mutexes and semaphores. 

## Questions

* How do peripherals that connect via bluetooth differ?

## C++ Tips

__attribute(packed)__ forces compiler to not align fields in structs and therefore use the minimum amount of bytes.




